# word_cat() 関数 - 要件定義書と詳細設計書

## プロジェクト概要

### プロジェクト名
**word_cat (Word Concatenation Module)**

### 目的
レキサー段階において、入力文字列から空白・メタ文字で区切られた単語（トークン値）を抽出し、クォートを含む連続した文字列を結合する機能を提供する。

### スコープ
- 入力文字列のパース（単語境界の検出）
- シングルクォート・ダブルクォートの処理
- クォート内外の文字列連結
- 未閉鎖クォートのエラー検出

---

## 1. 要件定義

### 1.1 機能要件

#### FR-1: 単語境界の検出
- **ID**: FR-WC-001
- **優先度**: 高
- **説明**: 空白文字（スペース、タブ）とメタ文字（`|`, `>`, `<`, `&&`, `||`, `(`, `)`）を単語の境界として認識する
- **入力**: 文字列の現在位置
- **出力**: 単語の終端位置
- **受け入れ基準**: 
  - 空白文字で単語が終了すること
  - メタ文字で単語が終了すること
  - クォート内の空白・メタ文字は境界と見なさないこと

#### FR-2: シングルクォート処理
- **ID**: FR-WC-002
- **優先度**: 高
- **説明**: シングルクォート `'` で囲まれた範囲を一つの文字列として抽出し、クォート記号自体も含めて結果に含める
- **入力**: シングルクォートで開始される文字列
- **出力**: 閉じクォートまでの文字列（クォート記号を含む）
- **受け入れ基準**:
  - `'hello world'` → `'hello world'` （クォート記号込み）
  - クォート内の空白・メタ文字が文字列の一部として扱われる
  - 未閉鎖クォートを検出しエラーを返す

#### FR-3: ダブルクォート処理
- **ID**: FR-WC-003
- **優先度**: 高
- **説明**: ダブルクォート `"` で囲まれた範囲を一つの文字列として抽出し、クォート記号自体も含めて結果に含める
- **入力**: ダブルクォートで開始される文字列
- **出力**: 閉じクォートまでの文字列（クォート記号を含む）
- **受け入れ基準**:
  - `"hello $USER"` → `"hello $USER"` （クォート記号込み、$USERは後段で展開）
  - クォート内の変数記号 `$` はそのまま保持される

#### FR-4: プレーン文字列処理
- **ID**: FR-WC-004
- **優先度**: 高
- **説明**: クォート外の通常文字列を抽出する
- **入力**: クォート外の文字列
- **出力**: 次の空白・メタ文字・クォートまでの文字列
- **受け入れ基準**:
  - `hello` → `hello`
  - `test123_var` → `test123_var`
  - 空白・メタ文字で終了する

#### FR-5: 文字列連結
- **ID**: FR-WC-005
- **優先度**: 高
- **説明**: クォート部分とプレーン部分を連続して結合し、一つの単語を形成する
- **入力**: 複数のクォート・プレーン文字列の組み合わせ
- **出力**: 連結された単語文字列
- **受け入れ基準**:
  - `hello'world'"test"` → `hello'world'"test"`
  - `$VAR'literal'"$HOME"` → `$VAR'literal'"$HOME"`
  - 動的メモリ再配置で文字列を拡張する

**設計注記**: クォート状態の詳細解析は`gen_word()`(parser段階)に完全に委譲される。`word_cat()`の責務は文字列連結のみ。

### 1.2 非機能要件

#### NFR-1: パフォーマンス
- **ID**: NFR-WC-001
- **優先度**: 中
- **説明**: 通常サイズの入力（～1000文字）を1ms以内で処理する
- **測定方法**: ベンチマークテスト

#### NFR-2: メモリ管理
- **ID**: NFR-WC-002
- **優先度**: 高
- **説明**: メモリリークを発生させない、エラー時には確保済みメモリを解放する
- **測定方法**: Valgrind検証

#### NFR-3: エラーハンドリング
- **ID**: NFR-WC-003
- **優先度**: 高
- **説明**: 未閉鎖クォートを検出し、適切なエラーメッセージを標準エラー出力に表示する
- **エラーメッセージ**: `minishell: syntax error: unclosed quote`

---

## 2. 詳細設計

### 2.1 関数シグネチャ

```c
size_t word_cat(
    char **word,           // [IN/OUT] 結果文字列へのポインタ(動的拡張)
    size_t word_len,       // [IN] 現在の単語長
    char const *input,     // [IN] 入力文字列全体
    size_t input_len,      // [IN] 入力文字列の長さ
    size_t *idx            // [IN/OUT] 現在のパース位置
);
```

**設計原則**: `word_cat()`の責務は文字列連結のみ。クォート状態の解析は`gen_word()`(parser段階)に完全に委譲される。

### 2.2 引数仕様

| 引数名 | 型 | 方向 | 説明 |
|--------|------|------|------|
| `word` | `char **` | IN/OUT | 結果を格納する文字列のポインタ。NULL開始可能。関数内で`ft_realloc()`により動的拡張される |
| `word_len` | `size_t` | IN | 現在の`*word`の文字列長（終端NULL除く） |
| `input` | `const char *` | IN | パース対象の入力文字列全体 |
| `input_len` | `size_t` | IN | `input`の全体長 |
| `idx` | `size_t *` | IN/OUT | 入力: 現在のパース開始位置、出力: パース終了後の位置 |

### 2.3 戻り値

| 値 | 説明 |
|----|------|
| `1` | 成功（単語の抽出完了） |
| `0` | 失敗（未閉鎖クォート、メモリ不足等） |

### 2.4 状態遷移図

```
[開始] 
  ↓
[位置チェック: *idx < input_len && !isspace && !is_meta]
  ↓ YES
[クォート判定: is_quote(input[*idx])]
  ↓ YES                          ↓ NO
[クォート処理]              [プレーン文字列処理]
  ↓                              ↓
[閉じクォート検索]          [次の境界まで読み進め]
  ↓ 見つかった  ↓ 未発見       ↓
[メモリ再配置]  [エラー]      [メモリ再配置]
  ↓              ↓             ↓
[文字列コピー]  [return 0]   [文字列コピー]
  ↓                            ↓
[idx更新]                  [idx更新]
  ↓                            ↓
[word_len更新]            [word_len更新]
  ↓──────────────────────────┘
  ↓
[ループ継続]
  ↓ 境界到達
[return 1]
```

### 2.5 データフロー

```
入力文字列 "echo 'hello world'\"test\""
    ↓
word_cat() 開始（idx=5, word=NULL, word_len=0）
    ↓
1. クォート検出: input[5] = '\''
    ↓
2. 閉じクォート検索: input[18] = '\''
    ↓
3. メモリ配置: word = realloc(NULL, 0, 14)
    ↓
4. 文字列コピー: memcpy(word, "'hello world'", 13)
    ↓
5. idx更新: idx = 19
    ↓
6. クォート検出: input[19] = '"'
    ↓
7. 閉じクォート検索: input[24] = '"'
    ↓
8. メモリ再配置: word = realloc(word, 14, 20)
    ↓
9. 文字列コピー: memcpy(word+13, "\"test\"", 6)
    ↓
10. idx更新: idx = 25
    ↓
結果: word = "'hello world'\"test\""
```

### 2.6 補助関数

#### 2.6.1 handle_plain()

```c
int handle_plain(
    char **word,
    size_t *word_len,
    char const *input,
    size_t input_len,
    size_t *idx
);
```

**目的**: クォート外のプレーン文字列を処理

**アルゴリズム**:
1. 現在位置から次の空白・メタ文字・クォートまでをスキャン
2. 読み取った長さ分メモリを再配置
3. 文字列をコピー
4. `word_len`と`idx`を更新

**エラーケース**:
- `add_len == 0`: 読み取り失敗（`return -1`）
- メモリ配置失敗: `return -1`

### 2.7 メモリ管理戦略

#### 動的拡張方式
- **使用関数**: `ft_realloc(old_ptr, old_size, new_size)`
- **拡張タイミング**: 新しい文字列セグメントを追加する毎
- **計算式**: `new_size = word_len + add_len + 1` （終端NULLを含む）

#### メモリレイアウト例

```
初期状態:
word = NULL, word_len = 0

第1セグメント追加後（"hello"）:
[h][e][l][l][o][\0]
 ↑               ↑
 word            word + 5 (word_len = 5)

第2セグメント追加後（"'world'"）:
[h][e][l][l][o]['world'][\0]
 ↑                       ↑
 word                    word + 12 (word_len = 12)
```

### 2.8 エラーハンドリング

| エラー種別 | 検出条件 | 処理 |
|------------|----------|------|
| 未閉鎖クォート | `ft_strchr(&input[*idx+1], quote) == NULL` | エラーメッセージ出力 → `return 0` |
| メモリ不足 | `ft_realloc()` が `NULL` 返却 | `return 0` |
| 読み取り長0 | `handle_plain()` で `add_len == 0` | `return -1` |

### 2.9 制約条件

1. **入力文字列**: NULL終端されている必要がある
2. **初期状態**: `*word`は`NULL`または有効なメモリポインタ
3. **word_len**: `*word`の実際の文字列長と一致している必要がある
4. **idx**: `input`の有効範囲内を指している必要がある

### 2.10 テストケース

#### 正常系

| テストID | 入力 | 期待出力 | 説明 |
|---------|----- |----------|------|
| TC-WC-001 | `"hello"` @ idx=0 | `word="hello"`, ret=1 | 単純なプレーン文字列 |
| TC-WC-002 | `"'test'"` @ idx=0 | `word="'test'"`, ret=1 | シングルクォート |
| TC-WC-003 | `"\"test\""` @ idx=0 | `word="\"test\""`, ret=1 | ダブルクォート |
| TC-WC-004 | `"a'b'\"c\""` @ idx=0 | `word="a'b'\"c\""`, ret=1 | 混合 |
| TC-WC-005 | `"test "` @ idx=0 | `word="test"`, ret=1, idx=4 | 空白で終了 |
| TC-WC-006 | `"test|"` @ idx=0 | `word="test"`, ret=1, idx=4 | メタ文字で終了 |

#### 異常系

| テストID | 入力 | 期待動作 | 説明 |
|---------|------|----------|------|
| TC-WC-E01 | `"'unclosed"` @ idx=0 | ret=0, エラーメッセージ出力 | 未閉鎖シングルクォート |
| TC-WC-E02 | `"\"unclosed"` @ idx=0 | ret=0, エラーメッセージ出力 | 未閉鎖ダブルクォート |

### 2.11 パフォーマンス分析

#### 時間計算量
- **最良ケース**: O(n) - nは単語の文字数
- **平均ケース**: O(n)
- **最悪ケース**: O(n)

#### 空間計算量
- **メモリ使用量**: O(n) - 結果文字列のサイズ
- **再配置回数**: クォート・プレーンセグメント数に比例（通常1～5回程度）

### 2.12 依存関係

#### 外部関数
- `ft_isspace()`: 空白判定
- `is_meta_char()`: メタ文字判定
- `is_quote()`: クォート判定
- `ft_strchr()`: 文字検索
- `ft_realloc()`: メモリ再配置
- `ft_memcpy()`: メモリコピー
- `ft_putstr_fd()`: エラー出力

#### ヘッダ
- `minishell.h`: プロジェクト全体のヘッダ

#### 後段依存
- `gen_word()` (parser段階): クォート状態の詳細解析を担当。`word_cat()`のフラグが設定されない混在ケースでも正確に処理する

---

## 3. 実装ガイドライン

### 3.1 コーディング規約
- 42 School Norm準拠
- 関数の長さ: 25行以内
- 1行の長さ: 80文字以内
- インデントはタブ

### 3.2 レビューチェックリスト
- [ ] メモリリークが無いこと（Valgrind検証済み）
- [ ] 未閉鎖クォートを正しく検出すること
- [ ] 全てのテストケースがパスすること
- [ ] エラーメッセージが正しく出力されること
- [ ] 境界値テストをパスすること（空文字列、最大長等）

### 3.3 保守性向上策
- 明確な関数名(`handle_plain`, `handle_quotation`等)
- 処理ブロックごとのコメント
- マジックナンバーの排除(定数定義)

### 3.4 設計原則

#### 単一責任の原則 (Single Responsibility Principle)
`word_cat()`の責務は**文字列連結のみ**に限定されている:
- クォートとプレーン文字列の連結
- 単語境界の検出
- 未閉鎖クォートのエラー検出

クォート状態の詳細解析は`gen_word()`(parser段階)に完全に委譲される。これにより:
- 関数シグネチャが簡素化される
- 役割分担が明確になり保守性が向上する
- テストが容易になる

---

## 4. 変更履歴

| 日付 | バージョン | 変更内容 | 担当者 |
|------|-----------|----------|--------|
| 2025-11-15 | 1.0 | 初版作成 | - |
| 2025-11-15 | 1.1 | FR-6に設計上の冗長性に関する注記を追加。将来の改善案をセクション3.4に追記 | - |
| 2025-11-15 | 2.0 | FR-6(クォートフラグ管理)を削除。関数シグネチャを簡素化。クォート状態解析をgen_word()に完全委譲。実装と設計を一致させる | - |

---

## 5. 承認

| 役割 | 氏名 | 日付 | 署名 |
|------|------|------|------|
| 設計者 | - | 2025-11-15 | - |
| レビュアー | - | - | - |
| 承認者 | - | - | - |
